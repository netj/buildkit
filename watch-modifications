#!/usr/bin/env bash
# watch-modifications -- Watch modifications in given modules
# Author: Jaeho Shin <netj@sparcs.org>
# Created: 2013-04-09
set -eu
shopt -s extglob

# abort if already running
pid="$BUILDDIR"/watch.pid
if [ -s "$pid" ] && ps -o command= -p $(cat "$pid" 2>/dev/null) | grep -q watchmedo; then
    exit 0
else
    rm -f "$pid"
fi

# initialize module modifications
[ -s "$BUILDDIR"/modules ]
xargs <"$BUILDDIR"/modules -I{}  rm -f "$BUILDDIR"/{}.lastmodified

# abort if we don't have watchmedo (See: https://pypi.python.org/pypi/watchdog)
type watchmedo &>/dev/null

# close I/O
exec </dev/null >"$BUILDDIR"/watch.log 2>&1
set -m

# use watchmedo to incrementally update the lastmodified links
watchmedo shell-command --recursive \
    --ignore-patterns="*/.git;*/.git/*;*/.build;*/.build/*;$BUILDDIR;$BUILDDIR/*;$STAGEDIR;$STAGEDIR/*" \
    --command='echo ${watch_event_type} "${watch_src_path}"' |
{
    # XXX A workaround for obscured file modified events
    # Sometimes when files are modified with a text editor in some
    # circumstances (e.g., Vim with 'writebackup' option on OS X), events for
    # parent directories are detected instead.  Therefore, we need to translate
    # directory events back to those for actual files contained in it.
    while read event abspath; do
        if [ -d "$abspath" ]; then
            case $event in
                modified)
                    # find which file is modified in the directory
                    found=false
                    for f in "$abspath"/{,.}*; do
                        ! [ -d "$f" ] || continue
                        ! [ "$f" -ot "$abspath" ] || continue
                        echo modified "$f"
                        found=true
                    done
                    $found || echo modified "$abspath"
                    continue
                    ;;
            esac
        fi
        echo "$event $abspath"
    done
} |
{
    # track module modifications from individual file events
    srcroot=$(pwd -P)
    cd "$BUILDDIR"
    eval "$(
        echo 'which-module() {'
        sort -r modules |
        generate-module-resolver
        echo '}'
    )"
    while read -t 1800 -r event abspath; do
        echo "# $event $abspath"
        case $abspath in
            "$srcroot") path=. ;;
            *) path=${abspath#$srcroot/} ;;
        esac
        # update lastmodified symlinks
        if module=$(which-module "$path"); then
            p=$abspath
            case $event in
                modified|created)
                    [ -e "$p" ] || p=$(most-recently-modified-files \
                        "$(dirname "$p")" -maxdepth 1 | head -n 1)
                    ;;
                deleted|moved|*)
                    p=$(dirname "$p")
                    ;;
            esac
            l="$module".lastmodified
            if [ "$p" -nt "$l" ]; then
                ld=$(dirname "$l")
                relpath="$(relpath "$ld" "$p")"
                mkdir -p "$ld"
                ln -sfnv "$relpath" "$l"
            fi
        else
            echo >&2 "$path: module unknown; ignored"
        fi
        # invalidate generated make rules when module metadata are modified
        case $path in
            */.module.install)
                rm -fv stage.mk
                case $event in created|deleted|moved) break ;; esac
                ;;
            */.module.build|*/.module.depends)
                rm -fv build.mk
                ;;
        esac
    done
    # watchmedo stays alive although the pipe sink exits, so kill it
    kill -TERM -$(ps -o pgid= -p $BASHPID | tr -d ' ')
} &

# record PGID
ps -o pgid= -p "$!" | tr -d ' ' >"$pid"
