#!/usr/bin/env bash
# generate-staging-rules -- Generate make rules for staging each module
# Author: Jaeho Shin <netj@sparcs.org>
# Created: 2010-07-24
set -eu
unset CDPATH
shopt -s extglob

echo '# Make rules for installing modules on stage'
echo -n '# Generated: '; date +%FT%T%:z
echo

dstdirs=()

: >"$BUILDDIR"/stage.contents
for Module; do
    echo "# $Module"
    # define module variables for use in destination pathnames
    MODULE_PATH=$Module
    MODULE_NAME=${Module##*/}
    while read line; do
        # discard comments and empty lines
        line=${line%%#*}
        line=${line//[	 ]/ }
        read srcpatt dstpatt rest <<<"$line" || continue
        [ -n "$srcpatt" -a -n "$dstpatt" ] || continue
        # expand source pathname
        for src in "$Module"/$srcpatt; do
            src=${src#"$Module"/}
            dst=$dstpatt
            srcname=${src%/}
            # expand destination pathname
            case $dst in
                */)
                    dst+=${srcname##*/}
                    ;;
            esac
            dst=`eval echo "$dst"`
            # TODO normalize path systematically
            dstdir="\$(STAGEDIR)/${dst%/*}/"
            dst=${dst#./}
            dstdir=${dstdir%./}
            dstpath=$dst
            # make explicit whether source is a directory or not in its name
            if [ -d "$Module/$src" ]; then
                src=${src%/}/
                dstpath+=/
            fi
            # generate staging rule
            echo "stage: \$(STAGEDIR)/$dst"
            echo "\$(STAGEDIR)/$dst: $Module/$srcname $dstdir"
            case $src in
                */) # a directory
                    # TODO is it better if we make rules for individual files?
                    echo "	mkdir -p \$@"
                    echo "	cp -rf \$</* \$@/"
                    echo "# XXX make doesn't know if files are changed inside a directory"
                    echo ".PHONY: \$(STAGEDIR)/$dst"
                    ;;
                *) # a file
                    echo "	cp -f \$< \$@"
                    ;;
            esac
            # record in stage contents
            echo "./$dstpath" >>"$BUILDDIR"/stage.contents
            # remember destination directory for later
            dstdirs+=("$dstdir")
        done
    done <"$Module"/.module.install 
    echo
done

# generate directory creation rules
if [ ${#dstdirs[@]} -gt 0 ]; then
    echo "# Directories"
    printf '%s\n' "${dstdirs[@]}" | awk '!a[$0]++ {print}' |
    while read dstdir; do
        echo "$dstdir:"
        echo "	mkdir -p \$@"
    done
fi

# generate stage contents list
(
cd "$BUILDDIR"
# augment the list with closure of parent directories
xargs -L1 dirname <stage.contents | sort -u >parents
dirnames() {
    {
        cat parents
        xargs -L1 dirname <parents
    } | sort -u >parents0
    if ! diff -q parents parents0 >/dev/null; then
        mv -f parents0 parents
        dirnames
    else
        rm -f parents0
    fi
}
dirnames
sort parents stage.contents >stage.contents.sorted
mv -f stage.contents.sorted stage.contents
rm -f parents
sed -n '\:/$: s:/$:\\(/.*\\)\\?$:p' <stage.contents >stage.contents.dirs
)
echo "stage:"
echo '	STAGEDIR=$(STAGEDIR) BUILDDIR=$(BUILDDIR) \'
echo "remove-stale-files"
